module mCOM2D;

import std.stdio, std.meta, std.traits, std.range, std.conv, std.string, std.typetuple, std.typecons, std.algorithm;
private import std.experimental.allocator, std.experimental.allocator.building_blocks.region;
private import core.sys.windows.windows, core.sys.windows.com, core.sys.windows.basetyps, core.sys.windows.oleauto, core.sys.windows.oaidl, core.sys.windows.unknwn, core.sys.windows.windef, core.sys.windows.wtypes, core.sys.windows.objidl, core.sys.windows.ole2;


pragma(lib, "ole32.lib");
pragma(lib, "OleAut32.lib");


// Must be used to initialize COM, only required once.
private static void[] CoTaskMem;
private static Region!() CoTaskAlloc;
static this() {	assert(SUCCEEDED(CoInitializeEx(null, 0)), "Error Initializing COM"); CoTaskMem = CoTaskMemAlloc(4*1024)[0..4*1024]; CoTaskAlloc = Region!()(CoTaskMem); }
static ~this() { CoTaskMemFree(CoTaskMem.ptr); CoUninitialize();  }





/* 
	Generates a D class, at compile time, for each of the interface in <Interfaces> from the module <mSName> that contains the D interfaces. 
	Each interface in the module <mSName> that will be wrapped must be prefixed by i. This is because the same name will be used for the 
	corresponding autogenerated D classes with the prefix i replaced by c. e.g., iMyCOMInterface -> cMyCOMInterface.
	Each function in the interface is mapped to a function pointer/delegate in the D class. These functions can/will be changed at runtime.
	
	<mSName> is the string name for the module that contains the interfaces(used for symbol resolution).
	<Interfaces> is a string list of the interfaces(without prefix i)
*/
static auto GenerateDCOMClasses(alias mSName, alias Interfaces, bool Cache = true)()
{
	mixin(`import `~mSName~";");	// Import base COM interface module to get valid symbols 
	mixin(`import mCOM2D;`);		
	enum VariantCR = GetVariantCR!string();	// Slow if not "cached"
	//pragma(msg, VariantCR);
	// Converts an iInterface function name to a cInterface function name. This allows COM interface methods to be delegated to their D wrapper class methods properly. 
	auto I2C(alias I, alias m)()
	{
		char[] s; s ~= m.FunctionPtrDeclaration.replace("extern (Windows) ", "").strip();
		s = ""~s.replace(" function(", " delegate(").strip();				
		foreach(q; aliasSeqOf!I) 
		{
			s = s.replace("i"~q~" ", "c"~q~" ");				
			s = s.replace("i"~q~",", "c"~q~",");				
			s = s.replace("i"~q~")", "c"~q~")");				
		}
		
		return s;
	}

	auto Get(alias T)()
	{
		alias m = T;
		auto lu = T.ReturnType[0];
		if (m.ReturnType[0] in VariantCR)
			lu = VariantCR[lu][0][1];
		else
		{

			auto ptr = (repeat("*", count(m.ReturnType[0], "*"))).join();
			auto pstr = ((ptr.length > 0) ? "p" : "");
			auto rtnp = m.ReturnType[0][0..$-ptr.length];

			// Handle compound "unknown" types(enums, interfaces, etc)
			switch(rtnp.toLower())
			{
				case "bool": lu = "short"~ptr; break;

				default: lu = "IUnknown"~ptr; break;
			}

			static if (m.ReturnType[1] == "enum")
				lu = "int";


			lu = VariantCR[lu~ptr][0][1];
		}
		return lu;
	}




	char[] s;
	char[] f;
	char[] invokeType, _body, _bodyRT, fnc; bool addFunc; bool hasGetter = false;
	string lastMethod; int lastPropertyType = -1; int overloadsCount = 0;	string MethodSuffix = "";
	int Icount = 0;
	char[] MainInterfaceName;
	foreach(i; aliasSeqOf!Interfaces)
	{
		Icount++;
		f.length = 0; lastPropertyType = -1; lastMethod = ""; overloadsCount = 0; MethodSuffix = "";
		mixin(`enum methods = Methods!(i`~i~`);`);	// Get COM interface methods		
		

		// Create D COM Wrapper class with all the same methods as the specified interface i
		s ~="public class c"~i~"\n{\n";
		s ~= "\t"; mixin(`s ~= "import "~moduleName!(i`~i~`)~", ";`); 
		s ~= "std.conv, mCOM2D, core.sys.windows.windows, core.sys.windows.com, core.sys.windows.wtypes, core.sys.windows.basetyps, core.sys.windows.unknwn, core.sys.windows.oaidl;\n";		
		s ~= "\tpublic IDispatch iDispatch = null;\n\tpublic IDispatch iDispatchParent = null;\n\tpublic IDispatch iDispatchQuery = null;\n\tpublic GUID iID = IID.init;\n\tpublic GUID clsID = IID.init;\n";
		static if (Cache)
		{
			s ~= "\tpublic static bool Cache = true;\n";			// Specifies class instance caching. This reuses class instances(since they generally are just a collection of methods, no real allocation need take place)
			s ~= "\tpublic static bool FastCache = true;\n";		// Fast caching only gets COM objects once and assumes they are valid throughout all calls. This may not be justified depending on what those COM interfaces actually do behind the scenes.
			if (Icount == 1)
			{
				s ~= "\tpublic static object.Object[string] CachedInterfaces;\n";
				MainInterfaceName ~= to!string(i);
			}

		}



		// Setup variables
		f ~= "\n\t\tiDispatchQuery = _Query;";
		f ~= "\n\t\tiDispatchParent = _Parent;";
		// Get dynamic COM Interface methods/ID's
		f ~= "\n\t\tauto COMInterface = GetDynamicCOMInterface!("~mSName~`.i`~i~", void, c"~i~")(this, null, _query);";
		
		
		

		// Add each delegate wrapper to the class for each method in the COM interface specified by the D interface i in Interfaces. 		
		foreach(m; aliasSeqOf!methods)
		{		
			addFunc = true;	invokeType.length = 0; fnc.length = 0; _body.length = 0; _bodyRT.length = 0;

			auto methodName = m.Name;			
			if (lastMethod == methodName) overloadsCount++; else overloadsCount = 0; 
			if (overloadsCount == 0) hasGetter = false;
			if (lastPropertyType != m.PropertyType) overloadsCount = 0; lastPropertyType = m.PropertyType;
			MethodSuffix = (overloadsCount > 1) ? "__"~to!string(overloadsCount) : "";			
			lastMethod = methodName;
			switch(m.PropertyType)
			{
				case -1: if (m.ParamsType.length <= 0) invokeType ~= "DISPATCH_PROPERTYGET"; else invokeType ~= "DISPATCH_METHOD"; break;				
				case 0: invokeType ~= "DISPATCH_PROPERTYGET"; if (methodName[0..3] == "get") methodName = methodName[3..$]; break;
				case 1,2,3: invokeType ~= "DISPATCH_PROPERTYPUT"; if (methodName[0..3] == "set") methodName = methodName[3..$]; break;
				default: assert(0, "Invalid Invoke Property Type!");
			}

			// Determines if the return time is one of the interfaces that are being wrapped by a class
			bool RTasClass = false;	
			foreach(j; aliasSeqOf!Interfaces)
				if (m.ReturnType[0][1..$] == j) RTasClass = true;							

			// Add interface method to class if it is extern (Windows) (which all COM interfaces are)
			static if (m.FunctionPtrDeclaration.canFind("extern (Windows)")) // Required if Methods uses exact function signature rather than generated.
			{				
				//pragma(msg, "Name = ", m.Name, ", RT = ", m.ReturnType, ", PT = ", m.ParamsType, ", FD = ", m.FunctionDeclaration, ", FPD = ", m.FunctionPtrDeclaration, " Property Type = ", m.PropertyType);
				

				auto fd = I2C!(AliasSeq!Interfaces, m);
				
				if (fd[0..8] == "VARIANT ")	
					fd = "SafeVariantPtr "~fd[8..$];	// Use a safer return type than Variant that cleans itself up.


				s ~= "\n\tpublic "~fd~" "~m.Name~MethodSuffix~";";

				// overload getters		
				if (m.PropertyType == 0) // If getter, add property
				{					
					lastPropertyType = 0;
					overloadsCount++;
					
				
					if (m.ReturnType[0] == "VARIANT")	
						s ~= "\n\tSafeVariantPtr "~(I2C!(AliasSeq!Interfaces, m).replace("delegate(", methodName~"("))[8..$];
					else
						s ~= "\n\t"~I2C!(AliasSeq!Interfaces, m).replace("delegate(", methodName~"(")~"";
					s ~= " { ";
					s ~= "return "~m.Name~MethodSuffix~"();";
					s ~= " } ";
					hasGetter = true;
				
				}

				// overload setters				
				if (m.PropertyType > 0)	// If getter, add property
				{					
					overloadsCount++;
					

					if (m.ReturnType[0] == "void")
						s ~= "\n\tauto"~(I2C!(AliasSeq!Interfaces, m).replace("delegate(", methodName~"("))[4..$];
					else if (m.ReturnType[0] == "VARIANT")	
						s ~= "\n\tSafeVariantPtr "~(I2C!(AliasSeq!Interfaces, m).replace("delegate(", methodName~"("))[8..$];
					else
						s ~= "\n\t"~I2C!(AliasSeq!Interfaces, m).replace("delegate(", methodName~"(");
					

					//TODO: Only return getter if it exists(else return return time if it is not void, else void)
					// Some getters do not exist to much check for it and not return if it exists.

					s ~= " { ";
					auto qqq2342 = "";
					for(auto k = 0; k < m.ParamsType.length; k++)
						qqq2342 ~= m.ParamsType[k][2]~", ";					 

					if (m.ReturnType[0] == "void")					
					{
						s ~= ""~m.Name~MethodSuffix~"("~qqq2342[0..$-2]~");";
						if (hasGetter)
							s ~= " return get"~methodName~"();";
					}
					else
					{
						s ~= "return "~m.Name~MethodSuffix~"("~qqq2342[0..$-2]~");";
					}
					s ~= " }";
					 
				}


				

				//----------------------------------				
				// Add wrappable COM functions
				
								

				// Fast caching
				static if (Cache)
				{			
					static if (m.ReturnType[0] != "void")
					{
						static if (m.ReturnType[1] == "interface")					
						{
							_body ~= "\tauto key = `"~i~"."~m.ReturnType[0][1..$]~"`;\n";
							if (RTasClass)
							{
								_body ~= "\tif (auto v = key in c"~MainInterfaceName~".CachedInterfaces)\n";
								_body ~= "\t{\n";							
								_body ~= "\t\treturn cast(c"~m.ReturnType[0][1..$]~")*v;\n";
								_body ~= "\t}\n";						
							}
						}
					}
				}
				//"assert(0, `Function c"~i~"."~m.Name~" not Implemented`);\n";

				
				_body ~= "\n\tEXCEPINFO exception;\n\tuint argErr = 0;\n\tauto iidNULL = IID_NULL;\n";
				_body ~= "\tauto RT = new SafeVariantPtr();\n";



				
				static if (m.ParamsType.length > 0)
					_body ~= "\tVARIANT["~to!string(to!int(m.ParamsType.length))~"] paramVars;\n";
				_body ~= "\tDISPPARAMS params = {rgvarg: "~((m.ParamsType.length > 0) ? "paramVars.ptr" : "null")~", cArgs: "~to!string(to!int(m.ParamsType.length))~", cNamedArgs: 0};\n";				
				_body ~= "\tauto ID = COMInterface[`"~methodName~"`].ID;\n";					
			
				// Handle Params
				int pindx = cast(int)m.ParamsType.length;
				//static if (m.ParamsType.length > 0) { pragma(msg, m.ParamsType); }
				foreach(p; m.ParamsType)
				{
					pindx--;
					//Need to map D params to variant params.. may have to allocate
					if (p[0] == "VARIANT")
					{
						_body ~= "\tparamVars["~to!string(pindx)~"] = "~to!string(p[2])~";\n";
					}
					else
					{
						_body ~= "\tparamVars["~to!string(pindx)~"].vt = "~to!string(VariantCR[p[1]][0][2])~";\n";
						_body ~= "\tparamVars["~to!string(pindx)~"]."~to!string(VariantCR[p[1]][0][1])~" = "~p[2]~";\n";
						_body ~= "\tscope(exit) VariantClear(&paramVars["~to!string(pindx)~"]);\n";
					}

					// TODO: Get param value in to Variant value. (requires a bit of hackery/parsing/mapping and possibly allocating/freeing)
					// Works so far but need to check robustness. Pass interfaces, and Variants, etc. works with simple built in primitives like double, etc.

				}

				//    HRESULT Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS*, VARIANT*, EXCEPINFO*, UINT*);

				_body ~= "\tauto res = c"~i~".iDispatch.Invoke(cast(int)ID, &iidNULL, 0, "~invokeType~", &params, cast(VARIANT*)RT, &exception, &argErr);\n";
				_body ~= "\tassert(res == S_OK, `Could not invoke COM Function c"~i~"."~m.Name~". Error `~to!string(res, 16));\n";
						

				static if (m.ReturnType[0] != "void")
				{
														

					auto lu = Get!(m)();
					//pragma(msg, m.ReturnType[0], " - ", m.ReturnType[1], " - ", m.FunctionPtrDeclaration);					

					static if (m.ReturnType[1] == "interface")					
					{

						if (!RTasClass)
							_bodyRT ~= "\treturn cast("~m.ReturnType[0]~")(RT."~lu~");\n";	
						else
						{

							static if (Cache)
							{								
								_bodyRT ~= "\tif (c"~MainInterfaceName~".Cache)\n\t{\n";
								_bodyRT ~= "\t\tif (auto v = key in c"~MainInterfaceName~".CachedInterfaces)\n\t\t{\n";
								_bodyRT ~= "\t\t\t(cast(c"~m.ReturnType[0][1..$]~")v).iDispatch = cast(IDispatch)RT.punkVal;\n";
								_bodyRT ~= "\t\t\treturn cast(c"~m.ReturnType[0][1..$]~")*v;\n";
								_bodyRT ~= "\t\t}\n\t}\n";	
								_bodyRT ~= "\tauto _class = new c"~m.ReturnType[0][1..$]~"(true, cast(IDispatch)(RT."~lu~"), this.iDispatch);\n";
								_bodyRT ~= "\tc"~MainInterfaceName~".CachedInterfaces[key] = _class;\n";
								_bodyRT ~= "\treturn _class;\n";

							} else
							{
								_bodyRT ~= "\tauto _class = new c"~m.ReturnType[0][1..$]~"(true, cast(IDispatch)(RT."~lu~"), this.iDispatch);\n";
								_bodyRT ~= "\treturn _class;\n";
							}
						}
									
					} else static if(m.ReturnType[1] == "class")
					{
						_bodyRT ~= "\treturn cast("~m.ReturnType[0]~")(RT."~lu~");\n";
					} else static if (m.ReturnType[0] == "VARIANT")
					{
						_bodyRT ~= "\treturn RT;\n";
					}
					else
					{
						_bodyRT ~= "\treturn cast("~m.ReturnType[0]~")(RT."~lu~");\n";					
					}

					_body ~= _bodyRT;
				}

				string plist;
				foreach(p; m.ParamsType)		 
				{
					plist ~= p[0]~" "~p[2]~", ";						
				}
				if (m.ParamsType.length > 0)
					plist = plist[0..$-2];

				fnc ~= "\n// "~m.FunctionDeclaration~"\n"~m.Name~MethodSuffix~" = cast(typeof(this."~m.Name~MethodSuffix~")) ("~plist~") \n{\n "~_body~"\n};\n";
				
				if (addFunc)												    
					f ~= "\n"~fnc.replace("\n", "\n\t\t");
				else 
					f ~= "\n\t\t"~m.Name~MethodSuffix~" = cast(typeof("~m.Name~MethodSuffix~")) { assert(0, `Function c"~i~"."~m.Name~"{"~MethodSuffix~"} not Implemented`); }; // "~m.FunctionDeclaration~"\n";

			}
		}

		 
		
		
		// Setup default constructor to initialize all delegate members with COM invoking mechanisms
		s ~= "\n\n\t// i"~i;
		s ~= "\n\tpublic this(bool _query = false, IDispatch _Query = null, IDispatch _Parent = null)\n\t{\n"~f~"\n\t}";

		// Release the COM interface on destruction
		s ~= "\n\t~this(){ if (iDispatch) iDispatch.Release(); }";


		s ~= "\n}\n\n";
	}

	return s;
}	



/* 
	Initializes, at runtime, the D COM class/interface <I>. Creates the COM instance(using CoCreateInstance or QueryInterface) of <I> and gets the 
	runtime COM "function pointer" for each member of <I>(Using the method names in I that correspond to the COM interface). 
	These function pointers returned along with the pointer to the COM interface.


	Usage: This function is called at runtime to setup the connection of a COM object to it's D COM Wrapper. 
	Interface: The COM D Interface with the methods, iID, and clsID to be used to generated a D COM Wrapper from.
	_this: The D COM Wrapper class instance to setup. 
	(optional)
		methods: the type tuple array of methods of the interface, used only for optimization, pass void to recache.
		query: To use Query interface. Pass COM interface to query in Parent.
		Parent: The parent aggregate COM interface or the COM interface to query, if query is set to true 
	Return: Returns a list of tuples indexed by the method names found in <Interface>. The first element is the COM ID(GetIDsOfNames) and the second is the Method info as returned by Methods!().
*/
static auto GetDynamicCOMInterface(Interface, methods = void, T)(T _this, IUnknown Parent = null, bool query = false)
{
	import mCOM2D;

	static if (is(methods == void))
		enum methods = Methods!(Interface);
	Tuple!(int, "ID", typeof(Methods!(_NULL, string)[0]), "Method")[string] COMMethods;			
	
	_this.iID = Interface.iID;
	static if (hasMember!(Interface, "clsID")) _this.clsID = Interface.clsID;

	HRESULT res;
	if (!query)
	{
		res = CoCreateInstance(&_this.clsID, Parent, CLSCTX_ALL, &_this.iID, cast(void**)&_this.iDispatch);
		assert(SUCCEEDED(res), "Error("~to!string(res, 16)~") Cannot Create COM Instance: " ~ Interface.stringof);
	} else
	{
		res = ((Parent is null) ? _this.iDispatchQuery : Parent).QueryInterface(&_this.iID, cast(void**)&_this.iDispatch);
		assert(SUCCEEDED(res), "Error("~to!string(res, 16)~") Cannot Query COM Instance: " ~ Interface.stringof);
	}
	

	// Get the IDs of all the methods in the interface. Iterate one at a time for convenience
	auto methodID = DISPID_UNKNOWN;
	auto iid2 = IID_NULL;
	auto methodNamePtr = cast(wchar**)CoTaskAlloc.allocate((void*).sizeof);


	// Get method name size(for preallocation)
	size_t size = 0; foreach(m; aliasSeqOf!methods) { size = max(size, m.Name.length); }
	auto methodName = cast(wchar[])CoTaskAlloc.allocate(size*2+10);			
	*methodNamePtr = cast(wchar*)methodName.ptr;



	// Get each methodID for each method.
	foreach(m; methods)
	{		
		// Copy name to buffer
		auto mName = m.Name;
		switch(m.PropertyType)
		{
			case -1: break;
			case 0: if (mName[0..3] == "get") mName = mName[3..$]; break;
			case 1,2,3: if (mName[0..3] == "set") mName = mName[3..$]; break;
			default: assert(0, "Invalid Invoke Property Type!");
		}
		assert(mName.length < 512, "GetDynamicCOMInterface: Method name too long!");
		for(int i = 0; i < mName.length; i++)
			methodName[i] = mName[i]; 
		methodName[mName.length] = '\0';		

		// Get COM method ID
		methodID = DISPID_UNKNOWN;
		res = _this.iDispatch.GetIDsOfNames(&_this.iID, methodNamePtr, 1u, 0u, &methodID);	// MethodNamePtr is of type wchar
		//assert(SUCCEEDED(res), "Error("~to!string(res, 16)~") Cannot Get COM Method `"~to!string(m.Name)~"` ID: ");		
		if (SUCCEEDED(res))
			COMMethods[mName] = tuple!("ID", "Method")(methodID, m);
	}

	CoTaskAlloc.deallocate(methodName);
	CoTaskAlloc.deallocate(methodNamePtr[0..(void*).sizeof]);

	return COMMethods;
}










// ------------------------------ Helper Functions
version(all)
{

	// Creates a 3-way lookup that maps a variant vt val to a field name and it's type and vice versa versa.
	auto GetVariantCR(S = string)()
	{
		// VARIANT & VARENUM structures
		enum data = [["0x00", "VT_EMPTY", "None"],["0x01", "VT_NULL", "None"],["0x02", "VT_I2", "iVal"],["0x03", "VT_I4", "lVal"],["0x04", "VT_R2", "fltVal"],["0x05", "VT_R4", "dblVal"],["0x06", "VT_CY", "cyVal"],["0x07", "VT_DATE", "date"],["0x08", "VT_BSTR", "bstrVal"],["0x09", "VT_DISPATCH", "pdispVal"],["0x0a", "VT_ERROR", "scode"],["0x0b", "VT_BOOL", "boolVal"],["0x0c", "VT_VARIANT", "pvarVal"],["0x0d", "VT_UNKNOWN", "punkVal"],["0x0e", "VT_DECIMAL", "decVal"],["0x10", "VT_I1", "cVal"],["0x11", "VT_UI1", "bVal"],["0x12", "VT_UI2", "uiVal"],["0x13", "VT_UI4", "ulVal"],["0x14", "VT_I8", "hVal"],["0x15", "VT_UI8", "uhVal"],["0x16", "VT_INT", "intVal"],["0x17", "VT_UINT", "uintVal"],["0x18", "VT_VOID", "void"],["0x19", "VT_HRESULT", "Missing3"],["0x1a", "VT_PTR", "ptr"],["0x1b", "VT_SAFEARRAY", "parray"],["0x1c", "VT_CARRAY", "carray"],["0x1d", "VT_USERDEFINED", "userdefined"],["0x1e", "VT_LPSTR", "pszVal"],["0x1f", "VT_LPWSTR", "pwszVal"],["0x24", "VT_RECORD", "record"],["0x25", "VT_INT_PTR", "pintVal"],["0x26", "VT_UINT_PTR", "puintVal"],["0x2000", "VT_ARRAY", "parray"]];

		import std.traits, std.meta, std.string, std.algorithm, std.typetuple, std.typecons, std.conv;	

		Tuple!(S, S, S, S)[][S] s;

		// Iterate over all fields of VARIANT	
		foreach (name; aliasSeqOf!((VARIANT.tupleof.stringof)[6..$-1].split(",").map!(n => strip(n)))) 
		{
			static if (name.among("vt", "pvRecord", "pRecInfo", "wReserved1", "wReserved2", "wReserved3")) { }
			else
			{
				mixin("alias type = typeof(VARIANT."~name~"); // "~name);
				//pragma(msg, "alias type = typeof(VARIANT."~name~"); // "~name~" -- "~type.stringof);

				S val; S n;
				foreach(x; data)
				{
					if (x[2] == name)				
					{
						auto q = x[0][2..$];
						int v = parse!int(q, 16);
						val = to!S(v);
						n = to!S(x[1]);

						break;
					}
				}
				if (!(val == "" || n == ""))
				{
					auto v = tuple(to!S(type.stringof)~"", to!S(name)~"", val~"", n~"");
					s[v[0]] ~= v; s[v[1]] ~= v; s[v[2]] ~= v; s[v[3]] ~= v;
				}

			}
			
		}
		
		// Add D maps
		auto v = tuple("interface", "punkVal", "13", "VT_UNKNOWN");
		s[v[0]] ~= v; s[v[1]] ~= v; s[v[2]] ~= v; s[v[3]] ~= v;
		v = tuple("class", "punkVal", "13", "VT_UNKNOWN");
		s[v[0]] ~= v; s[v[1]] ~= v; s[v[2]] ~= v; s[v[3]] ~= v;
		v = tuple("interface*", "ppunkVal", "13", "VT_PTR");
		s[v[0]] ~= v; s[v[1]] ~= v; s[v[2]] ~= v; s[v[3]] ~= v;
		v = tuple("class*", "ppunkVal", "13", "VT_PTR");
		s[v[0]] ~= v; s[v[1]] ~= v; s[v[2]] ~= v; s[v[3]] ~= v;

		v = tuple("enum", "intVal", "22", "VT_INT");
		s[v[0]] ~= v; s[v[1]] ~= v; s[v[2]] ~= v; s[v[3]] ~= v;

		v = tuple("enum", "intVal", "22", "VT_INT");
		s[v[0]] ~= v; s[v[1]] ~= v; s[v[2]] ~= v; s[v[3]] ~= v;
		
		v = tuple("bool", "intVal", "11", "VT_BOOL");
		s[v[0]] ~= v; s[v[1]] ~= v; s[v[2]] ~= v; s[v[3]] ~= v;
		return s;
	}



	// Wraps a VARIANT to provide automatic initialization and cleanup.
	class SafeVariantPtr
	{
		VARIANT* v;
		alias v this;
		bool allocated = false;
		this()
		{
			v = cast(VARIANT*)CoTaskMemAlloc(VARIANT.sizeof);
			allocated = true;
			VariantInit(v);
		} 

		this(ref VARIANT v)
		{
			this.v = &v;			
		} 

		~this()
		{												 
			import std.conv;
			auto res = VariantClear(v);
			assert((res == S_OK), "Cannot clear COM Variant: "~to!string(res, 16));
			if (allocated)
				CoTaskMemFree(v);
		}
	}


	// Creates a guid from a guid hex string. e.g., "B3C35001-B625-48D7-9D3B-C9D66D9CF5F1" -> {0xC09F153E, 0xDFF7, 0x4EFF, [0xA5, 0x70, 0xAF, 0x82, 0xC1, 0xA5, 0xA2, 0xA8]}
	GUID Guid(string str)() 
	{
		static assert(str.length==36, "Guid string must be 36 chars long");
		enum GUIDstring = "GUID(0x" ~ str[0..8] ~ ", 0x" ~ str[9..13] ~ ", 0x" ~ str[14..18] ~ 
			", [0x" ~ str[19..21] ~ ", 0x" ~ str[21..23] ~ ", 0x" ~ str[24..26] ~ ", 0x" ~ str[26..28]
			~ ", 0x" ~ str[28..30] ~ ", 0x" ~ str[30..32] ~ ", 0x" ~ str[32..34] ~ ", 0x" ~ str[34..36] ~ "])";
		return mixin(GUIDstring);
	}


	import std.algorithm;
	enum isElementOfObject(alias T) = (staticIndexOf!(T, AliasSeq!("this", __traits(allMembers, Object))) >= 0) ? true : false;
	enum isElementOfIDispatch(alias T) = (staticIndexOf!(T, __traits(allMembers, IDispatch)) >= 0) ? true : false;	
	enum isConstructor(alias T) = (T.stringof.canFind("Ctor")) ? true : false;	
	class _NULL { }


	// Returns a D primitive type string
	S dType(T, S = string)() {
		static if(is(T == enum)) return "enum";
		else static if(is(T == class)) return "class";
		else static if(is(T == struct)) return "struct";
		else static if(is(T == interface)) return "interface";
		else return T.stringof;
	}

	// Returns only the methods for a class or interface by Name, Parameters(specified type, D type), Return(specified type, D type), Function Declaration, then Function Ptr Declaration
	auto Methods(alias T, S = string)() if ((is(T == class) || is(T == interface)) && (is(S == string) || is(S == wstring)))	// returns method name, params + return type. Params is array of types(specified as a (s)string)
	{
		
		import std.traits, std.typetuple, std.typecons, std.array, std.string, std.conv, std.meta;
		alias RT = Tuple!(S, "Name", Tuple!(S,S,S)[], "ParamsType", Tuple!(S,S), "ReturnType", S, "FunctionDeclaration", S, "FunctionPtrDeclaration", int, "PropertyType");	// PropertyType = [not a property: -1, get:0, set:1, setref:2, set/setref:3,]
		RT[] methods;

		mixin("import "~moduleName!(T)~";");
	
		static if (is(T == _NULL)) return methods;
		
		// Get only useful members(not this, IDispatch, Object, etc)
		enum membersList = Filter!(templateNot!isConstructor, Filter!(templateNot!isElementOfIDispatch, Filter!(templateNot!isElementOfObject, __traits(allMembers, T))));
		foreach(f;  membersList)
		{
			alias overloads = AliasSeq!(__traits(getOverloads, T, f));

			foreach (member; overloads)
			{
			
				enum member_name = (to!S(__traits(identifier, member)) ~ to!S("\0"))[0..$-1];	// Append null terminator for c usage, should add no harm but if we unslice it and it may be lost in rare cases and cause issues when used in c.
				static if (is(typeof(member) == function) || is(typeof(*member) == function))
				{
					typeof(methods[0].ParamsType) params;

					enum p = split(Parameters!(member).stringof[1..$-1], ",").map!(n => strip(n));					 
					static if (ParameterIdentifierTuple!(member).length == 0)
						enum pns = [];
					else
						mixin("enum pns = ["~to!S(ParameterIdentifierTuple!(member).stringof[6..$-1])~"];");
					
					
					auto k = 0;
					foreach(a; aliasSeqOf!(p)) 
					{
						mixin("enum x = dType!("~to!S(removechars(strip(a), "*"))~")~repeat(`*`, count(a, `*`)).join();");
						params ~= tuple(to!S(strip(a))~"", to!S(x)~"", to!S(pns[k++])~"");
					}
				
					string prefix = ""; int ptype = -1;
					if (overloads.length == 2)
					{
						
						prefix = (p.length == 0) ? "get" : "set";
						ptype = (p.length == 0) ? 0 : 1;
					}
					// TODO: Handle get/set/setref (I think the IDL to D converts all sets to setrefs)

					// Store method data
					mixin(`typeof(&member) memptr;`);				
					mixin(`alias md = typeof(member);`);		
					enum rt = ReturnType!(member).stringof~"";				
					mixin("enum rtv = dType!("~to!S(removechars(strip(rt), "*"))~")~repeat(`*`, count(rt, `*`)).join();");
					methods ~= typeof(methods[0])(prefix~member_name~"", params, tuple(to!S(rt)~"", to!S(rtv)~""), to!S(md.stringof)~"", to!S(typeof(memptr).stringof)~"", ptype);
				}
			}
		}
		return methods;	
	}	
}


/* Notes/Issues

1.1 When setting the property of a COM object via IDispatch::Invoke() using DISPATCH_PROPERTYPUT, it is important to ensure the following :

    DISPPARAMS.rgdispidNamedArgs must point to a DISPID whose value is
    DISPID_PROPERTYPUT (-3).
    DISPPARAMS.cNamedArgs must be equal to 1.

1.2 If the above settings are not done, IDispatch::Invoke() will return DISP_E_PARAMNOTFOUND.


If Invoke was successful, then result.vt will be VT_DISPATCH and result.dispVal will be a valid IDispatch pointer. 

*/